---
layout:             post
title:                 软工读书笔记(3)
subtitle:           Chap 12-18：软件设计
date:      	        2018-04-09
author:             Shaw
header-img:     img/post-bg-re-vs-ng2.jpg
catalog: 	         true
tags:
        - 软件工程
        - 读书笔记
---

>本文参考自 Software Engineering : A Practitioner’s Approach — 8th edition by Roger S. Pressman

12、软件设计概念
-

需求与设计
-
- 需求和设计之间的界限不明显
- 区别大概是(what to do 和 how to do)

模块化 (modularity)
-
- (类似程序里 function 的概念)
- 模块不要太少，也不要太多，因为会有 integration cost

内聚性 (cohesion)
-
- 越高越好
- 内聚性描述一个模块的各机能凝聚的状态或程度
- 理想状况下，一个内聚的模块只实现单一独立的功能

耦合性 (coupling)
-
- 越低越好
- 耦合性测量模块之间的信息交互量
- 高耦合性使得模块不易维护、不易测试、不易复用以及难以理解

面向切面编程
-

(AOP 是 Aspect Oriented Programming 的首字母缩写)

![面向切面编程](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/AOP.jpg "面向切面编程")

>面向切面编程

13、架构设计 (architectural design)
-
如同楼房建筑需要架构设计，软件也需要整体架构设计

data-centered architecture
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/data-centered.png)

data-flow architecture
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/data-flow.png)

call-and-return architecture
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/call_return.png)

layered architecture
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/layered.png)

13.6 上下文 (context) 分析
-
- 确立上下文
	- 软件会和外部实体 (其他系统、设备、人员) 进行交互
	- 上下文分析帮助码农认识这个软件的边界

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/context.png)

>上下文图示

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/architecture.png)

>软件架构例子

14、构件级设计 (component-level design)
-
**构件级设计**发生在第一次**架构设计** (上一章) 完成之后。这时，笼统的数据和程序结构已经建立，需要完善各种细节，把模型草稿转化为能运行的软件。

14.1 什么是构件？
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/add_component.png)

>在架构中加入构件

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/elaboration.png)

>OOP例子：上部和中部是**构件级设计**的输入，下部是**构件级设计**的输出

>之所以要把构件连接 interface，是因为 interface 定义了当前构件与其他构件的接口，比如为 **PricingTable** 构件提供`computePageCost()`服务接口，为 **JobQueue** 构件提供 `checkPriority()`服务接口。这俩接口对应图中的两个“棒棒糖”。

14.2 OOP 构件设计
-
Open-Closed Principle (OCP)
-
