---
layout:             post
title:                 软件工程读书笔记
subtitle:           Chap 1-5
date:      	        2018-02-15
author:             Shaw
header-img:     img/post-bg-re-vs-ng2.jpg
catalog: 	         true
tags:
        - 软件工程
---

>本文参考自 Software engineering : a practitioner’s approach — Eighth edition by Roger S. Pressman

1.1 软件的特性
-
- 软件决定了现代信息化社会的发展
- 以往个体的程序员正在被软件开发团队取代
	- 团队个体间有序分工
- 控制开发成本
	- 时间，预算
	- debug
	- 更新、修复 现有的软件系统
	- 评测开发/维护进度
	
软件不会老化
-
硬件|软件
-|-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/hardware_fail.png)|![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/software_fail.png)

但是，软件会**折旧**！
-
- 软件会面临来自各方的改进建议
	- 时间：上线前 - 运行很久之后
		- 每次更改会带来高失败率
		- 没等到完全稳定，新的更改又来
		- 最终更改太多，软件“折旧”了
- 软件出bug一般意味着更深层的问题，因此也更复杂

1.1.2 七类软件
- 
- 系统软件
- 商业软件
- 工程软件
- 嵌入式软件
- 消费级软件
- Web/手机软件
- 人工智能软件

1.1.3 老软件
-
- 历史遗留软件很多
	- 核心，不可替代
	- 难以适应新环境、新需求
- 怎么办？Do nothing.
	- 直到“不得不”改进

1.2 四种流行的新软件
-
- WebApps
- 手机App
- 云计算
- product line software？？？

2.2.1 process包含的5个阶段
-
- communication
	- project启动
	- 收集用户需求信息
- planning
	- cost/benefit估计
	- 时间安排
	- 资源投入
- modeling
	- 打草稿
	- 分析+设计
- construction
	- 写代码
	- 测试
- deployment
	- 部署，交付给用户
	- 技术支持
	- 用户反馈+评分

2.2.2 Umbrella Activities
-
执行上述阶段时要注意的方面：

- Software project tracking and control
	- 帮助大家了解项目进行到哪个阶段
- Risk management
- Software quality assurance
- Technical reviews
	- 同行代码审阅
- Measurement
- Software configuration management
	- 控制“更改代码的影响”
- Reusability management
- Documentation

3.1 process的4种通用型流程
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/process_flow.png)

4、process模型
-
秩序(order)与混乱(chaos)是软件流程的光谱的两个极端

4.1.1 Waterfall
-
- 需求是已知确定+固定的
- 一次成型，不能适应变化/更改
- 用户必须能耐心等到最后的阶段
- 后面的模块要等待前面模块完成

V-model （瀑布模型的变体）
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/v_model.png)

4.1.2 Incremental Process Models
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/incremental.png)
- 快速向用户提供基础功能
- 同时具备linear和parallel的特征
- 需要从一开始就可拓展

4.1.3 Evolutionary Process Models
-
- 需求未来会更改
- 要求尽快上线

Prototyping
-
- 第一个版本很可能又慢又大又难用
- 用户可以今早体验使用
- 程序员可以尽早写code

>从Communication开始

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/prototype.png)

- 用户可能觉得这个prototype已经够用了，从而要求尽快上线
	- 实际上，目前的版本存在深层bug且不可维护
- 程序员可能会为了尽快交差而敷衍
- 因此，需要和客户约定好，这个prototype只是用来确认需求

Spiral Model
-
- 每一次循环都提供一个完整功能的软件

>从Communication开始

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/spiral.png)

- 第一个循环确认需求
- 第二个循环之后依次产生prototype
- 适合大型软件开发
	- 在各个的阶段产生prototype

缺点
- 需要经常进行risk assessment
- 不确定需要多少个cycle

4.1.4 Concurrent models
-
- 任一时间都可以进行任一操作
	- 任何时间都能modeling
	- 任何时间就能communication
	
4.2 特殊process
-
- Component-Based Development
	- 使用/购买第三方开发的Commercial off-the-shelf模块，直接拿来集成到现有的系统内
- Formal Methods Model
	- 一个变体叫做cleanroom software engineering
	- 不太主流
		- 成本高，需要大量培训
		- 难以与客户沟通
	- 使用在性命攸关（医疗设备）+巨额损失（Amazon）系统

4.3 Unified process
-
- 集成传统的软件开发方法
- 使用UML描述requirements和design模型

>以下5个阶段可能以concurrency的方式运行

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/united_process.png)

5、Agile Development
-

价值驱动法 |	计划驱动法 |	正式法
-|-|-
低临界 |	高关键性 |	极端的危险
资深开发人员 |	初级开发者 	|资深开发人员
需求经常变化 |	需求不经常改变 	|有限的需求
少量的开发人员 |	大量的开发人员 |	可以建模的需求
响应变化的文化 |	要求秩序的文化 |	极致的品质

>敏捷软件开发宣言

- 个体和互动：高于流程和工具
- 工作的软件：高于详尽的文档
- 客户合作：高于合同谈判
- 响应变化：高于遵循计划

---
- agile不一定适应所有的项目、产品、人员、环境
- 但是，快速变化的（手机软件）市场使得“完全了解需求”变的不可能
- agile最大的优势是“适应变化”

5.2 Change的成本
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/agile_cost.png)

- Agile可以平坦化传统的成本
	- 尤其是在使用unit testing和pair programming的情况下

5.3 Agile的内容
-
- 最重要的是通过尽早和不断交付有价值的软件满足客户需要
- 客户和开发者在整个项目过程中应该始终朝夕在一起工作
- 在开发小组中面对面的交谈
- 可以工作的软件是进度的主要度量标准
- 测试是在每一次迭代（iteration）中完成的
	- 开发一小部分软件，用户可以经常使用这些新的软件并验证其价值

对比其他的方法
-
敏捷方法有时候被误认为是无计划性和纪律性的方法，实际上更确切的说法是敏捷方法强调适应性而非预见性。

适应性的方法集中在快速适应现实的变化。当项目的需求起了变化，团队应该迅速适应。这个团队可能很难确切描述未来将会如何变化.

- 对比迭代方法
	- 相比迭代式开发两者都强调在较短的开发周期提交软件，敏捷方法的周期可能更短，并且更加强调队伍中的高度协作。
- 对比瀑布式开发
	- 两者没有很多的共同点，瀑布模型是最典型的预见性的方法，严格遵循预先计划的需求、分析、设计、编码、测试的步骤顺序进行。步骤成果作为衡量进度的方法，例如需求规格，设计文档，测试计划和代码审阅等等。
	- 瀑布式的主要的问题是它的严格分级导致的自由度降低，项目早期即作出承诺导致对后期需求的变化难以调整，代价高昂。瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。

5.4 Extreme programming (XP)
-
- Pair programming
- 开发人员和客户之间当场交互
- 测试用例在实际代码之前就被写出来
- 如果一段代码没有经过测试，就不能认为它可以工作

5.5 Scrum方法
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/scrum.png)

- (Product) Backlog
	- 本质上是一个关于需求的priority queue
	- 可以随时插入新的需求并改变priority
- Sprint (Backlog)
	- 正在进行中，不可更改
	- 30天内对这些需求进行编程
- Scrum meetings
	- 每天站立进行，每次15分钟
	- 每个人讲自己的进展、困难、短计划