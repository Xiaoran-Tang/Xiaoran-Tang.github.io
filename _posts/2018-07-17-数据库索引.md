---
layout:             post
title:                 数据库索引
subtitle:           聚集索引，非聚集索引，反向索引
date:      	        2018-07-17
author:             Shaw
header-img:     img/home-bg.jpg
catalog: 	         true
tags:
        - 数据挖掘
---
>本文参考自 [深入浅出数据库索引原理](https://zhuanlan.zhihu.com/p/23624390)，[笔试面试知识整理](https://hit-alibaba.github.io/interview/basic/db/DB-Index.html) 以及 [什么是反向索引](https://www.jianshu.com/p/56d01fe7ff8d) 

1、聚集索引
-
本节回答下列问题：
- 为什么要给表加上主键？
- 为什么加索引后会使查询变快？
- 为什么加索引后会使写入、修改、删除变慢？

1.1 概念
-

想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是 B tree 或者 B+ tree，重要的事情说三遍：“平衡树，平衡树，平衡树”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的 RDBMS 都是把平衡树当做数据表默认的索引数据结构的。

我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/带有主键的表.jpg)

上图就是带有主键的表（聚集索引）的结构图。图画的不是很好， 将就着看。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 

1.2 搜索数据
-
假如我们执行一个 SQL 语句：

```sql
SELECT * 
FROM table 
WHERE id = 1256;
```

首先根据索引定位到`1256`这个值所在的叶结点，然后再通过叶结点取到`id`等于`1256`的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/搜索带有主键的表.jpg)

假如一张表有一亿条数据 ，需要查找其中某一条数据，按照常规逻辑， 一条一条的去匹配的话， 最坏的情况下需要匹配一亿次才能得到结果，用大O标记法就是O(n)最坏时间复杂度，这是无法接受的，而且这一亿条数据显然不能一次性读入内存供程序使用， 因此， 这一亿次匹配在不经缓存优化的情况下就是一亿次IO开销，以现在磁盘的IO能力和CPU的运算能力， 有可能需要几个月才能得出结果 。如果把这张表转换成平衡树结构（一棵非常茂盛和节点非常多的树），假设这棵树有10层，那么只需要10次IO开销就能查找到所需要的数据， 速度以指数级别提升，用大O标记法就是O(log n)，n是记录总树，底数是树的分叉数，结果就是树的层次数。换言之，查找次数是以树的分叉数为底，记录总数的对数，用公式来表示就是

$$ log_{树的分叉数}(记录总数)=查找次数$$

用程序来表示就是`Math.Log(100000000, 10)`，100000000是记录数，10是树的分叉数（真实环境下分叉数远不止10）， 结果就是查找次数，这里的结果从亿降到了个位数。因此，利用索引会使数据库查询有惊人的性能提升。

1.3 缺点
-
然而， 事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。

2、非聚集索引
-
非聚集索引，也就是我们平时经常提起和使用的常规索引。

2.1 概念
-
非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 如下图

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/非聚集索引.jpg)

每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。

2.2 搜索数据
-
非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，如下图

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/从非聚集索引查找.jpg)

不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。

2.3 什么时候加索引？
-
- 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。
- 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。
- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- 在经常使用在`WHERE`子句中的列上面创建索引，加快条件的判断速度。

3、反向索引
-
反向索引 (inverted index) 是一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。它是文档检索系统中最常用的数据结构。（Elasticsearch 的底层 Lucene 就使用反向索引。）

正向索引：文档 ---> 单词
反向索引：单词 ---> 文档

创建反向索引，首先需要对原始文档数据进行编号 (DocID)，生成一个文档列表：
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/反向索引1.jpg)

然后，对文档中数据进行分词，得到单词。用单词创建索引，并进行编号。最后记录下包含该单词的所有文档编号：

![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/反向索引2.jpg)