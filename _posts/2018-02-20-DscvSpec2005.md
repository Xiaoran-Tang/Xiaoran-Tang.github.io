---
layout:             post
title:                 DscvSpec
subtitle:           Discovering Likely Method Specifications
date:      	         2018-02-20
author:             Shaw
header-img:     img/post-bg-miui6.jpg
catalog: 	         true
tags:
        - 软件测试
        - 读paper笔记
---

> 这篇paper的完整题目是 
Discovering Likely Method Specifications

>[下载链接](https://www.microsoft.com/en-us/research/wp-content/uploads/2006/03/tr-2005-146.pdf) 

Motivation
-
- static
	- 之前的工具生成的 pre/postconditions 过于细节，用户难以使用
	- 对于 loop 中的 invariants，之前的工具只能把 specifications 表示为 fields of classes
	- 只能分析“simple patterns”
	- 生成的 specification 结果过于抽象
- dynamic
	- Daicon 的能力受限于 input
	- Daicon 不太适合推断 **conditional invariant**？

背景
-
- 软件的 specifications 在（正式的）测试中很重要
	- 在自动化检查中，specifications 可以生成测试、检查运行结果
- 但是 specifications 总是缺失
	- 所以我们需要从现有的代码中寻找可能的 specifications
- 推断的 specifications 的质量取决于 code 本身的质量

Intro
-
- 以往的研究包括静态分析和动态分析
	- 前者接近白盒测试，后者接近黑盒测试
- 本文联合这两种分析模式，先静再动
	- 静分析，动归纳整理
- 本文主要分析包含 **abstract data types** (ADTs) 的 class
	- 程序员需要把 method 分为两类：只读(observer) 和 可写(modifier)
	- 本方法试图用 observer methods 来抽象的描述 modifier method
- 自动化的生成适合用户使用的 pre/postconditions
	- 可以直接 feed 给已有的单元测试工具使用

Steps
-
![](https://raw.githubusercontent.com/xiaoran-tang/xiaoran-tang.github.io/master/img/DscvSpec.png)

- 1、选择一个 method，用随机的初始参数进行符号执行
	- 试图遍历所有路径，但是只对 loop 进行有限的探索
- 2、分析 observer methods 获得 PC 的 observational abstraction？
	- 这一步获取很多的 path-specific axioms
		- 描述 observer method 在各种条件下的行为
- 3、把这些 axioms 进行合并、简化、筛选

2、例程
-
```java
public class Set {
	int[] repr;
	public Set(int maxSize) { 
		repr = new int[maxSize]; 
	}
	
	public void Add(int x) {
		if (x == 0) 
			throw new ArgumentException();
		int free = -1;
		for (int i = 0; i < repr.Length; i++)
			if (repr[i] == 0) 
				free = i;	// remember index
			else if (repr[i] == x)		// duplicate
				throw new InvalidOperationException();
		if (free != -1) 
			repr[free] = x; 			// success
		else // no free slot means we are full
			throw new InvalidOperationException();
	}
	
	public bool IsFull() {
		for (int i = 0; i < repr.Length; i++)
			if (repr[i] == 0) return false;
		return true;
	}
	public bool Contains(int x) {
		if (x == 0) throw new ArgumentException();
		for (int i = 0; i < repr.Length; i++)
			if (repr[i] == x) 
				return true;
		return false;
	}
}
```

不足
-
- 只考虑单线程，没有 concurrency