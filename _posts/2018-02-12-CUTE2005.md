---
layout:             post
title:                 CUTE: A Concolic Unit Testing Engine for C
subtitle:           concolic = concrete + symbolic
date:      	         2018-02-12
author:             Shaw
header-img:     img/post-bg-miui6.jpg
catalog: 	         true
tags:
        - 软件测试
        - 读paper笔记
---

> 这篇paper的完整题目是 
CUTE: A Concolic Unit Testing Engine for C

>[下载链接](http://mir.cs.illinois.edu/marinov/publications/SenETAL05CUTE.pdf) 

摘要
-
- 在单元测试中，argument有时会出现pointer。这时，input可看作是 memory graph
- 本paper回答“当input是 memory graph 时，如何进行自动化的单元测试？”
- 这个方法混合了**symbolic**和**concrete execution**
	- 使用这种混合物来**生成测试input**
	- 访问所有可能的路径
- 这个方法用 memory graph 来表示并追踪约束条件
	- 从而理解 symbolic execution 的行为
- 本文还给出了一个有效的 constraint solver
	- 帮助 incrementally 生成测试input
- 合并以上的功能，就是CUTE
	- 应用在C语言的程序上

1、Intro
-
- **单元测试**是一种模块化测试
	- 每个unit包含一组function
	- 各个unit独立测试
	- 人工生成 **test inputs** 是昂贵的，而且不全面
- 为了增加 **test coverage**，我们寻找自动化的方法
	- 随机测试
		- 许多值是**redundant**，因为在执行相同的功能
		- 找到”生成bug的值“的几率极其小
	- 符号执行
		- 使用符号变量代替实际变量
		- 每个 conditional expression 决定一条 execution path
		- 程序的 feasible execution 可以组成一棵树
			- node 是 branch point
		- 目的是生成“遍历所有路径”的实际值
		- 传统的方法是 深度优先搜索+回溯法
			- 但是，对于大型或复杂的单元，精确维护和解决测试生成所需的约束在计算上是棘手的
- 前人做过的concolic：
	- 第一篇concolic的方法是，先运行用户提供的具体的 test case，生成符号化PC，再对这些PC取反求解？
	- Godefroid的方法是，对执行路径上的PC取交集，然后系统化的取反，获得一个 深度优先搜索。如果无法求解某个PC，那就随便扔个随机数进去
		- PC难以提取和求解，尤其是有pointer的程序
		- 比如，pointer有alias
		- 符号执行解不出来
- 本文的方法：求解**近似指针约束 (approximate
pointer constraints)**来生成测试用例
	- 
	
2、程序例子
-

3、CUTE构造
-
3.1 Logical Input Map
-
3.2 Units and Program Model
-
3.3 Instrumentation
-
3.4 Concolic Execution
-
3.5 约束求解 (Constraint Solving)
-
3.6 Data Structure Testing
-
3.7 Approximations for Scalable Symbolic Execution
-

4、应用与实验
-
